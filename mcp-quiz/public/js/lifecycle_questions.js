export default {
  questions: [
    {
      id: "l1",
      question: "MCPのライフサイクルの最初のフェーズは何ですか？",
      options: [
        "動作フェーズ",
        "初期化フェーズ",
        "認証フェーズ",
        "通知フェーズ",
      ],
      correctAnswer: 1,
      explanation:
        "MCPのライフサイクルは初期化フェーズから始まります。このフェーズでクライアントとサーバーは互いの機能と設定を交換します。",
    },
    {
      id: "l2",
      question:
        "MCPのライフサイクルにおける「初期化済み通知」（InitializedNotification）の目的は何ですか？",
      options: [
        "サーバーがクライアントを初期化したことを通知する",
        "クライアントがサーバーに初期化が完了したことを通知する",
        "両方が相互に初期化されたことを確認する",
        "初期化エラーを通知する",
      ],
      correctAnswer: 1,
      explanation:
        "クライアントは「初期化済み通知」（InitializedNotification）をサーバーに送信して、初期化が完了したことを通知します。このタイミングで動作フェーズが始まります。",
    },
    {
      id: "l3",
      question:
        "MCPの初期化フェーズで交換される情報として正しくないものはどれですか？",
      options: [
        "クライアント/サーバーの名前とバージョン",
        "サポートされる機能と拡張機能",
        "ユーザー認証情報",
        "プロトコルのバージョン",
      ],
      correctAnswer: 2,
      explanation:
        "初期化フェーズでは、ユーザー認証情報は交換されません。認証は別のメカニズムで処理されます。交換されるのは名前、バージョン、プロトコルバージョン、サポートされる機能などです。",
    },
    {
      id: "l4",
      question:
        "MCPの動作フェーズ中、クライアントとサーバーはどのようにしてメッセージをやり取りしますか？",
      options: [
        "クライアントからサーバーへの一方向通信のみ",
        "サーバーからクライアントへの一方向通信のみ",
        "クライアントが要求し、サーバーが応答するだけ",
        "双方向で任意のメッセージを送信可能",
      ],
      correctAnswer: 3,
      explanation:
        "動作フェーズでは、クライアントとサーバーは双方向で任意のメッセージ（リクエスト、レスポンス、通知）をやり取りできます。",
    },
    {
      id: "l5",
      question: "MCPの終了フェーズはどのように開始されますか？",
      options: [
        "タイムアウトの発生",
        "ExitRequestの送信",
        "接続の強制切断",
        "ShutdownRequestの送信",
      ],
      correctAnswer: 3,
      explanation:
        "終了フェーズはクライアントまたはサーバーがShutdownRequestを送信することで開始されます。",
    },
    {
      id: "l6",
      question: "MCPのライフサイクルの最後のフェーズは何ですか？",
      options: [
        "切断フェーズ",
        "終了フェーズ",
        "シャットダウンフェーズ",
        "クリーンアップフェーズ",
      ],
      correctAnswer: 0,
      explanation:
        "ライフサイクルの最後のフェーズは切断フェーズです。このフェーズでは、物理的な接続が閉じられ、リソースがクリーンアップされます。",
    },
    {
      id: "l7",
      question:
        "MCPの初期化リクエスト（InitializeRequest）に含まれるべき情報として必須ではないものは？",
      options: ["名前", "バージョン", "プロトコルバージョン", "OS情報"],
      correctAnswer: 3,
      explanation:
        "OS情報は初期化リクエストに必須の情報ではありません。必須情報は名前、バージョン、プロトコルバージョンなどです。",
    },
    {
      id: "l8",
      question:
        "初期化フェーズでエラーが発生した場合、どのように処理されますか？",
      options: [
        "常に再試行が行われる",
        "エラーレスポンスが返され、接続が閉じられる",
        "デフォルト設定で続行される",
        "警告通知が送信されるが処理は続行される",
      ],
      correctAnswer: 1,
      explanation:
        "初期化フェーズでエラーが発生した場合、エラーレスポンスが返され、接続は閉じられます。初期化は成功するか失敗するかのどちらかです。",
    },
    {
      id: "l9",
      question:
        "MCPのシャットダウンリクエスト（ShutdownRequest）の後、サーバーとクライアントはどのように対応しますか？",
      options: [
        "サーバーが直ちに終了する",
        "クライアントが直ちに接続を切断する",
        "基盤となるトランスポートメカニズムを使用して接続終了を通知する",
        "互いに確認メッセージを送信してから切断する",
      ],
      correctAnswer: 2,
      explanation:
        "シャットダウンリクエスト後は、基盤となるトランスポートメカニズム（stdioの場合は入力ストリームの閉鎖、HTTPの場合はHTTP接続の閉鎖）を使用して接続終了を通知します。",
    },
    {
      id: "l10",
      question:
        "クライアントが初期化リクエストを送信した後、サーバーが対応していないプロトコルバージョンを返した場合、クライアントはどうすべきですか？",
      options: [
        "対応するバージョンに切り替える",
        "エラーを報告して再試行する",
        "切断する",
        "警告を表示して続行する",
      ],
      correctAnswer: 2,
      explanation:
        "クライアントがサーバーのレスポンスに含まれるプロトコルバージョンをサポートしていない場合、切断するべきです。",
    },
    {
      id: "l11",
      question:
        "MCPの初期化フェーズ中、クライアントとサーバーが送信できるのはどのメッセージですか？",
      options: [
        "すべてのメッセージタイプ",
        "初期化リクエストとレスポンスのみ",
        "初期化メッセージとpingのみ",
        "初期化メッセージ、ping、およびログメッセージのみ",
      ],
      correctAnswer: 3,
      explanation:
        "初期化フェーズ中、クライアントはinitializeリクエストとpingのみを送信すべきで、サーバーはpingとログメッセージのみを送信すべきです。",
    },
    {
      id: "l12",
      question:
        "MCPにおけるタイムアウトの処理方法として正しいものはどれですか？",
      options: [
        "タイムアウトは無視され、クライアントはレスポンスを無期限に待つ",
        "タイムアウト時には常にエラーが返される",
        "タイムアウト時には、キャンセル通知を送信し、レスポンスを待つのをやめる",
        "タイムアウト時には自動的に再試行が行われる",
      ],
      correctAnswer: 2,
      explanation:
        "リクエストがタイムアウト期間内にレスポンスを受信していない場合、送信者はそのリクエストに対するキャンセル通知を発行し、レスポンスを待つのをやめるべきです。",
    },
    {
      id: "l13",
      question:
        "MCPの初期化リクエストがJSON-RPCバッチの一部として送信されるべきではない理由は何ですか？",
      options: [
        "バッチ処理は常に非効率的だから",
        "初期化が完了するまで他のリクエストや通知が不可能だから",
        "バッチ処理はMCPでサポートされていないから",
        "サーバーがバッチリクエストを処理できないから",
      ],
      correctAnswer: 1,
      explanation:
        "初期化リクエストはJSON-RPCバッチの一部としてはならない理由は、初期化が完了するまで他のリクエストや通知は不可能だからです。これにより、以前のプロトコルバージョンとの後方互換性も確保されます。",
    },
    {
      id: "l14",
      question:
        "MCPのプロトコルバージョンネゴシエーションでは、クライアントとサーバーはどのバージョンを送信すべきですか？",
      options: [
        "サポートする最も古いバージョン",
        "サポートする最新のバージョン",
        "互換性のある任意のバージョン",
        "常に特定のバージョン（例：2024-11-05）",
      ],
      correctAnswer: 1,
      explanation:
        "クライアントとサーバーの両方がサポートする最新のプロトコルバージョンを送信すべきです。",
    },
    {
      id: "l15",
      question:
        "MCPのタイムアウト処理において、進捗通知（progress notification）を受信した場合、実装はどのように対応すべきですか？",
      options: [
        "タイムアウトカウンターをリセットすべきではない",
        "タイムアウトカウンターをリセットしてもよい",
        "タイムアウトカウンターを2倍に増やすべき",
        "タイムアウト処理を完全に無効化すべき",
      ],
      correctAnswer: 1,
      explanation:
        "実装は、リクエストに対応する進捗通知を受信した場合、タイムアウトクロックをリセットしてもよいです。これは作業が実際に行われていることを示唆しているためです。",
    },
  ],
};
